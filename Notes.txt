a. Two pointer solution

Definition1: The length of two linked list intersection linked list is definitely shorter or equal to the length of shorter linkedlist.
Definition2: Do not konw the length of linkedlist until the pointer reach to the end node.  

Case 1:  two linked list with same length
 (1) intersection:  
 If two linked list with same length have intersection, then each pointer will find the intersection node at the same time 
 before they reach end node of each linked list.
 (2) no intersection: 
 If two linked list with same length have no intersection, then each pointer will reach the end node at the same time.
 
Case 2:  two linked list with different length
 (1) intersection: 
 After the shorter linked list reach the end node, the next node is the head of longer linked list. 
 the step count of the pointer of the shorter list do before get to is definitely equal to 
 the subtraction of two linked list(we don't need to consider the subtraction of two linked list, becuase Definition1). As a 
 result, when the pointer of longer linked list reach the end node(the next node is the head of shorter linked list), the left 
 step count of the both linked list pointer is definitely equal to each other (Case 1:two linked list have same length).
 (2) no intersection:  If two linked list with different length have no intersection, both pointer will reach the end node of other linkedlist 
 after the both pointer reach the head of other linkedlist.  
 


b. HashSetSolution
HashSet 
# Backed by Hash Table(actually a HashMap instance).
# Iteration order of the HashSet is not the same as the input order of the element of the HashSet. 
# Permits null value.
# The basic operations(add, remove, contains, size) of HashSet run in O(1)
  , assuming the hash function disperses the elements properly among the buckets.
#  The expected time is O(1), since the average number of keys in each bucket of the HashSet is bound by a small constant. 
   At the worst case (if all the keys are mapped to the same bucket), the search would take linear time
   , but unless you have a terrible hashCode method, the worst case is not expected to ever happen.
# Not synchronized. Should be wrapped using Collections.synchronizedSet.
    Set s = Collections.synchronizedSet(new HashSet(...));
# The iterators returned by this class's iterator method are fail-fast.
# No dulplicate objects are allowed in HashSet.
# HashSet thinks two objects identical only when their hashCode() and equal() function return the same value
  , it use equal() to identify whether this object is equal to one of the objects having the same hashCode().  

Referenced List
# https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html
# https://stackoverflow.com/questions/25247854/hashset-contains-performance
